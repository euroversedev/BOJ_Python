import sys

tetrominos = [[(0,0), (0,1), (0,2), (0,3)], [(0,0), (1,0), (2,0), (3,0)],
            [(0,0), (0,1), (1,0), (1,1)],
            [(0,0), (1,0), (2,0), (2,1)], [(0,0), (0,1), (0,2), (-1,2)],
            [(0,0), (-1,0), (-2,0), (-2,-1)], [(0,0), (0,-1), (0,-2), (1,-2)],
            [(0,0), (1,0), (2,0), (2,-1)], [(0,0), (0,-1), (0,-2), (-1,-2)],
            [(0,0), (-1,0), (-2,0), (-2,1)], [(0,0), (0,1), (0,2), (1,2)],
            [(0,0), (1,0), (1,1), (2,1)], [(0,0), (0,1), (-1,1), (-1,2)],
            [(0,0), (-1,0), (-1,1), (-2,1)], [(0,0), (0,1), (1,1), (1,2)],
            [(0,0), (0,1), (-1,1), (0,2)], [(0,0), (1,0), (1,1), (2,0)],
            [(0,0), (0,1), (1,1), (0,2)], [(0,0), (0,1), (-1,1), (1,1)]]

N, M = map(int, input().split())
board = [list(map(int, sys.stdin.readline().strip().split()))
        for _ in range(N)]

MAX = -(10**9)
for i in range(N):
    for j in range(M):
        for tetromino in tetrominos:
            sum_ = 0
            breaker = False
            for dy, dx in tetromino:
                if 0<=i+dy<N and 0<=j+dx<M:
                    sum_ += board[i+dy][j+dx]
                else:
                    breaker =True
                    break
            
            if breaker:
                continue
            else:
                if sum_ > MAX:
                    MAX = sum_
                
print(MAX)
            

''' [review]
N이 크지않아서 브루트 포스로 풀릴듯
=> 중첩 반복이 너무 깊어서 시간 초과 뜸
=> tetrominos는 결국 한 지점으로 부터 이동할 수 있는 4칸까지와 동일함. 
=> dfs로 풀자 14500_2.py
'''